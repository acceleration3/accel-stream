#ifndef ACCEL_STREAM_HEADER
#define ACCEL_STREAM_HEADER

#include <string>
#include <vector>
#include <stdexcept>

#include <cctype>
#include <cstdint>
#include <cstdio>
#include <cstring>

#include <accel/endianness>
#include <accel/macros>

namespace accel
{
    namespace stream
    {
        enum class seek_references
	    {
		    current,
		    begining,
		    end
	    };

        enum class file_mode
        {
            text,
            binary
        };

        namespace details
        {
            static constexpr std::size_t max_string_size = 1024;

            static int get_seek_reference(seek_references reference)
            {
                static int references[3] = { SEEK_CUR, SEEK_SET, SEEK_END };
                return references[static_cast<std::size_t>(reference)];
            }

            static std::size_t calculate_offset(std::size_t memory_size, std::size_t position, std::size_t offset, seek_references reference)
            {
                std::size_t new_offset;
                if (reference == seek_references::begining)
                {
                    new_offset = offset;
                }
                else if (reference == seek_references::current)
                {
                    std::size_t current_offset = position;
                    new_offset = current_offset + offset;
                }
                else // reference == seek_references::end
                {
                    std::size_t end_offset = memory_size - 1;
                    new_offset = end_offset - offset;
                }

                if (new_offset >= memory_size || new_offset < 0)
                    throw std::runtime_error("Seeking past memory limits.");

                return new_offset;
            }
        }

        class input_stream
        {
        public:
            input_stream() = default;
            virtual ~input_stream() = default;

            ACC_NON_COPYABLE(input_stream);
            ACC_DEFAULT_MOVABLE(input_stream);

            virtual void seek_read(std::size_t offset, seek_references reference) = 0;
            virtual std::size_t read_position() const = 0;
            virtual std::size_t read(char* data, std::size_t size) = 0;
            virtual bool at_end() const = 0;

            template<typename T>
            input_stream& operator>>(T& data)
            {
                read(reinterpret_cast<char*>(&data), sizeof(data));
                return *this;
            }

            template<endianness::endiannesses Endianness = endianness::endiannesses::host_endian, typename T>
            std::size_t read_object(T& object)
            {
                auto size = read(reinterpret_cast<char*>(&object), sizeof(object));
                if (size != sizeof(object))
                    throw std::runtime_error("Failed to read object.");
                endianness::swap_endianness<endianness::endiannesses::host_endian, Endianness>(object);
                return size;
            }

            template<typename T>
            std::size_t read_object_le(T& object)
            {
                return read_object<endianness::endiannesses::little_endian>(object);
            }

            template<typename T>
            std::size_t read_object_be(T& object)
            {
                return read_object<endianness::endiannesses::big_endian>(object);
            }
        };

        template<>
        input_stream& input_stream::operator>><std::string>(std::string& data)
        {
            std::size_t current_size = 0;
            
            while (current_size < details::max_string_size)
            {
                char new_char = 0;
                auto read_bytes = read(&new_char, sizeof(char));
                current_size++;
                if (new_char == 0 || read_bytes == 0 || at_end())
                    break;
                data.push_back(new_char);
            }

            return *this;
        }

        class output_stream
        {
        public:
            output_stream() = default;
            virtual ~output_stream() = default;

            ACC_NON_COPYABLE(output_stream);
            ACC_DEFAULT_MOVABLE(output_stream);

            virtual void seek_write(std::size_t offset, seek_references reference) = 0;
            virtual std::size_t write_position() const = 0;
            virtual std::size_t write(const char* data, std::size_t size) = 0;

            template<typename T>
            output_stream& operator<<(const T data)
            {
                write(reinterpret_cast<const char*>(&data), sizeof(data));
                return *this;
            }

            template<endianness::endiannesses Endianness, typename T>
            std::size_t write_object(T object)
            {
                endianness::swap_endianness<endianness::endiannesses::host_endian, Endianness>(object);
                auto size = write(reinterpret_cast<const char*>(&object), sizeof(object));
                if (size != sizeof(object))
                    throw std::runtime_error("Failed to write object.");
                return size;
            }

            template<typename T>
            std::size_t write_object_le(T object)
            {
                return write_object<endianness::endiannesses::little_endian>(object);
            }

            template<typename T>
            std::size_t write_object_be(T object)
            {
                return write_object<endianness::endiannesses::big_endian>(object);
            }
        };

        template<>
        output_stream& output_stream::operator<<<const char*>(const char* data)
        {
            std::size_t current_size = 0;
            
            while (current_size < details::max_string_size)
            {
                char new_char = data[current_size];
                current_size++;
                auto written_bytes = write(&new_char, sizeof(char));
                if (new_char == 0 || written_bytes == 0)
                    break;
            }

            return *this;
        }

        template<>
        output_stream& output_stream::operator<<<std::string>(std::string data)
        {
            return operator<<<const char*>(data.c_str());
        }

        class stream : public input_stream, public output_stream {};

        class file_input_stream : public input_stream
        {
        public:
            file_input_stream(std::string path, file_mode mode)
            {
                m_file = fopen(path.c_str(), mode == file_mode::binary ? "rb" : "rt");
                if (!m_file)
                    throw std::runtime_error("Failed to open file.");
            }
            
            ~file_input_stream()
            {
                if (m_file)
                    fclose(m_file);
            }

            ACC_NON_COPYABLE(file_input_stream);
            
            file_input_stream(file_input_stream&& other)
            {
                m_file = other.m_file;
                other.m_file = nullptr;
            }

            file_input_stream& operator=(file_input_stream&& other)
            {
                m_file = other.m_file;
                other.m_file = nullptr;
                return *this;
            }

            void seek_read(std::size_t offset, seek_references reference) override
            {
                if (fseek(m_file, offset, details::get_seek_reference(reference)) != 0)
                    throw std::runtime_error("Failed to seek file");
            }

            std::size_t read_position() const override
            {
                return ftell(m_file);
            }

            std::size_t read(char* data, std::size_t size) override
            {
                std::ptrdiff_t read = fread(data, 1, size, m_file);
                if (read < 0)
                    throw std::runtime_error("Failed to read file");
                return read;
            }

            bool at_end() const override
            {
                return feof(m_file);
            }

        private:
            FILE* m_file;
        };

        class file_output_stream : public output_stream
        {
        public:
            file_output_stream(std::string path, file_mode mode)
            {
                m_file = fopen(path.c_str(), mode == file_mode::binary ? "wb" : "wt");
                if (!m_file)
                    throw std::runtime_error("Failed to open file.");
            }
            
            ~file_output_stream()
            {
                if (m_file)
                    fclose(m_file);
            }

            ACC_NON_COPYABLE(file_output_stream);

            file_output_stream(file_output_stream&& other)
            {
                m_file = other.m_file;
                other.m_file = nullptr;
            }

            file_output_stream& operator=(file_output_stream&& other)
            {
                m_file = other.m_file;
                other.m_file = nullptr;
                return *this;
            }

            void seek_write(std::size_t offset, seek_references reference) override
            {
                if (fseek(m_file, offset, details::get_seek_reference(reference)) != 0)
                    throw std::runtime_error("Failed to seek file");
            }

            std::size_t write_position() const override
            {
                return ftell(m_file);
            }

            std::size_t write(const char* data, std::size_t size) override
            {
                return fwrite(data, 1, size, m_file);
            }

        private:
            FILE* m_file;
        };
    
        class file_stream : public stream
        {
        public:
            file_stream(std::string path, file_mode mode)
            {
                m_file = fopen(path.c_str(), mode == file_mode::binary ? "r+b" : "r+t");
                if (!m_file)
                    throw std::runtime_error("Failed to open file.");
            }

            ~file_stream()
            {
                if (m_file)
                    fclose(m_file);
            }

            ACC_NON_COPYABLE(file_stream);
            
            file_stream(file_stream&& other)
            {
                m_file = other.m_file;
                other.m_file = nullptr;
            }

            file_stream& operator=(file_stream&& other)
            {
                m_file = other.m_file;
                other.m_file = nullptr;
                return *this;
            }

            void seek_read(std::size_t offset, seek_references reference) override
            {
                if (fseek(m_file, offset, details::get_seek_reference(reference)) != 0)
                    throw std::runtime_error("Failed to seek file");
            }

            std::size_t read_position() const override
            {
                return ftell(m_file);
            }

            std::size_t read(char* data, std::size_t size) override
            {
                return fread(data, 1, size, m_file);
            }

            bool at_end() const override
            {
                return feof(m_file);
            }

            void seek_write(std::size_t offset, seek_references reference) override
            {
                if (fseek(m_file, offset, details::get_seek_reference(reference)) != 0)
                    throw std::runtime_error("Failed to seek file");
            }

            std::size_t write_position() const override
            {
                return ftell(m_file);
            }

            std::size_t write(const char* data, std::size_t size) override
            {
                return fwrite(data, 1, size, m_file);
            }

        private:
            FILE* m_file;
        };

        class memory_input_stream : public input_stream
        {
        public:
            memory_input_stream(const std::vector<char>& memory) : 
                m_memory(memory),
                m_read_position(0) {}

            memory_input_stream(std::vector<char>&& memory) : 
                m_memory(std::move(memory)),
                m_read_position(0) {}
            
            ~memory_input_stream() = default;

            ACC_NON_COPYABLE(memory_input_stream);
            ACC_DEFAULT_MOVABLE(memory_input_stream);

            void seek_read(std::size_t offset, seek_references reference) override
            {
                m_read_position = details::calculate_offset(m_memory.size(), m_read_position, offset, reference);
            }

            std::size_t read_position() const override
            {
                return m_read_position;
            }

            std::size_t read(char* data, std::size_t size) override
            {
                if (m_read_position >= m_memory.size())
                    return 0;

                std::size_t remaining = m_memory.size() - m_read_position;
                std::size_t n = std::min(size, remaining);
                std::memcpy(data, m_memory.data() + m_read_position, n);
                
                m_read_position += n;

                return n;
            }

            bool at_end() const override
            {
                return m_read_position == m_memory.size();
            }

        private:
            std::size_t m_read_position;
            std::vector<char> m_memory;
        };

        class memory_output_stream : public output_stream
        {
        public:
            memory_output_stream(std::size_t initial_capacity = 1024) :
                m_write_position(0)
            {
                m_memory.reserve(initial_capacity);
            }

            ~memory_output_stream() = default;

            ACC_NON_COPYABLE(memory_output_stream);
            ACC_DEFAULT_MOVABLE(memory_output_stream);

            void seek_write(std::size_t offset, seek_references reference) override
            {
                m_write_position = details::calculate_offset(m_memory.size(), m_write_position, offset, reference);
            }

            std::size_t write_position() const override
            {
                return m_write_position;
            }

            std::size_t write(const char* data, std::size_t size) override
            {
                std::size_t available = m_memory.size() - m_write_position;
                if (size <= available) 
                {
                    std::memcpy(m_memory.data() + m_write_position, data, size);
                    m_write_position += size;
                    return size;
                } 
                else 
                {
                    std::memcpy(m_memory.data() + m_write_position, data, available);
                    m_memory.insert(m_memory.end(), data + available, data + size);
                    m_write_position += size;
                    return size;
                }
            }

            const char* data() const
            {
                return m_memory.data();
            }

            std::size_t size() const
            {
                return m_memory.size();
            }

        private:
            std::size_t m_write_position;
            std::vector<char> m_memory;
        };

        class memory_stream : public stream
        {
        public:
            memory_stream() :
                m_write_position(0),
                m_read_position(0) {}

            memory_stream(const std::vector<char>& memory) : 
                m_memory(memory),
                m_write_position(0),
                m_read_position(0) {}

            memory_stream(std::vector<char>&& memory) : 
                m_memory(std::move(memory)),
                m_write_position(0),
                m_read_position(0) {}
            
            ~memory_stream() = default;

            ACC_NON_COPYABLE(memory_stream);
            ACC_DEFAULT_MOVABLE(memory_stream);

            void seek_read(std::size_t offset, seek_references reference) override
            {
                m_read_position = details::calculate_offset(m_memory.size(), m_read_position, offset, reference);
            }

            std::size_t read_position() const override
            {
                return m_read_position;
            }

            std::size_t read(char* data, std::size_t size) override
            {
                std::ptrdiff_t overread = (m_read_position + size) - m_memory.size();
                if (overread > 0)
                    size -= overread;

                auto begin = m_memory.begin() + m_read_position;
                auto end = begin + size;
                std::copy(begin, end, data);
                
                m_read_position += size;

                return size;
            }

            bool at_end() const override
            {
                return m_read_position == m_memory.size();
            }

            void seek_write(std::size_t offset, seek_references reference) override
            {
                m_write_position = details::calculate_offset(m_memory.size(), m_write_position, offset, reference);
            }

            std::size_t write_position() const override
            {
                return m_write_position;
            }

            std::size_t write(const char* data, std::size_t size) override
            {
                std::size_t available = m_memory.size() - m_write_position;
                if (size <= available) 
                {
                    std::memcpy(m_memory.data() + m_write_position, data, size);
                    m_write_position += size;
                    return size;
                } 
                else 
                {
                    std::memcpy(m_memory.data() + m_write_position, data, available);
                    m_memory.insert(m_memory.end(), data + available, data + size);
                    m_write_position += size;
                    return size;
                }
            }

            const char* data() const
            {
                return m_memory.data();
            }

            std::size_t size() const
            {
                return m_memory.size();
            }

        private:
            std::size_t m_write_position;
            std::size_t m_read_position;
            std::vector<char> m_memory;
        };

    }
}

#endif